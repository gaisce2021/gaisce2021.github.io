<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AVL Trees</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>

<body>

<header>
    <p>Learn to Code</p>
</header>

<nav>
    <a href="../../../index.html">Site Home</a>
    <a href="../index.html">About Me</a>
    <div class="dropdown">
        <button class="dropbtn">Programming Basics
            <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
            <a href="../programmingBasics/lesson1.html">Lesson 1 - Getting Started</a>
            <a href="../programmingBasics/lesson2.html">Lesson 2 - Data Types</a>
            <a href="../programmingBasics/lesson3.html">Lesson 3 - Strings</a>
            <a href="../programmingBasics/lesson4.html">Lesson 4 - Booleans and Conditions</a>
            <a href="../programmingBasics/lesson5.html">Lesson 5 - Numerics and Functions</a>
            <a href="../programmingBasics/lesson6.html">Lesson 6 - Lists and Tuples</a>
            <a href="../programmingBasics/lesson7.html">Lesson 7 - Loops</a>
            <a href="../programmingBasics/lesson8.html">Lesson 8 - Print vs Return</a>
            <a href="../programmingBasics/lesson9.html">Lesson 9 - Errors</a>
            <a href="../programmingBasics/lesson10.html">Lesson 10 - Dictionaries</a>
            <a href="../programmingBasics/lesson11.html">Lesson 11 - Recursion</a>
            <a href="../programmingBasics/lesson12.html">Lesson 12 - List Comprehensions</a>
            <a href="../programmingBasics/lesson13.html">Lesson 13 - Revision</a>
        </div>
    </div>
    <div class="dropdown">
        <button class="dropbtn">Object Oriented Programming
            <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
            <a href="../oop/lesson14.html">Lesson 14 - Getting Started</a>
            <a href="../oop/lesson15.html">Lesson 15 - Inheritance</a>
            <a href="../oop/lesson16.html">Lesson 16 - Encapsulation</a>
            <a href="../oop/lesson17.html">Lesson 17 - Polymorphism</a>
            <a href="../oop/lesson18.html">Lesson 18 - Abstraction</a>
            <a href="../oop/lesson19.html">Lesson 19 - Text Based Game I</a>
            <a href="../oop/lesson20.html">Lesson 20 - Text Based Game II</a>
            <a href="../oop/lesson21.html">Lesson 21 - Text Based Game III</a>
            <a href="../oop/lesson22.html">Lesson 22 - Text Based Game IV</a>
            <a href="../oop/lesson23.html">Lesson 23 - Graphics Based Game I</a>
            <a href="../oop/lesson24.html">Lesson 24 - Graphics Based Game II</a>
            <a href="../oop/lesson25.html">Lesson 25 - Graphics Based Game III</a>
            <a href="../oop/lesson26.html">Lesson 26 - Graphics Based Game IV</a>
        </div>
    </div>
    <div class="dropdown">
        <button class="dropbtn">Data Structures
            <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
            <a href="../dataStructures/lesson27.html">Lesson 27 - Getting Started</a>
            <a href="../dataStructures/lesson28.html">Lesson 28 - Stacks</a>
            <a href="../dataStructures/lesson29.html">Lesson 29 - Queues</a>
            <a href="../dataStructures/lesson30.html">Lesson 30 - Linked Lists I</a>
            <a href="../dataStructures/lesson31.html">Lesson 31 - Linked Lists II</a>
            <a href="../dataStructures/lesson32.html">Lesson 32 - Priority Queues</a>
            <a href="../dataStructures/lesson33.html">Lesson 33 - Binary Trees</a>
            <a href="../dataStructures/lesson34.html">Lesson 34 - Binary Search Trees</a>
            <a href="../dataStructures/lesson35.html">Lesson 35 - AVL Trees</a>
            <a href="../dataStructures/lesson36.html">Lesson 36 - Deques</a>
            <a href="../dataStructures/lesson37.html">Lesson 37 - Graphs I</a>
            <a href="../dataStructures/lesson38.html">Lesson 38 - Graphs II</a>
            <a href="../dataStructures/lesson39.html">Lesson 39 - Graphs III</a>
        </div>
    </div>
    <div class="dropdown">
        <button class="dropbtn">Placeholder B
            <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
            <a href="../apis/lesson40.html">Lesson 40</a>
            <a href="../apis/lesson41.html">Lesson 41</a>
            <a href="../apis/lesson42.html">Lesson 42</a>
            <a href="../apis/lesson43.html">Lesson 43</a>
            <a href="../apis/lesson44.html">Lesson 44</a>
            <a href="../apis/lesson45.html">Lesson 45</a>
            <a href="../apis/lesson46.html">Lesson 46</a>
            <a href="../apis/lesson47.html">Lesson 47</a>
            <a href="../apis/lesson48.html">Lesson 48</a>
            <a href="../apis/lesson49.html">Lesson 49</a>
            <a href="../apis/lesson50.html">Lesson 50</a>
            <a href="../apis/lesson51.html">Lesson 51</a>
            <a href="../apis/lesson52.html">Lesson 52</a>
        </div>
    </div>
</nav>

<main>
    <h1>Questions</h1>
    <h2>Is it possible to make the BST more efficient?</h2>
    <p>
        Yes it is! Last week we talked briefly about inefficiency in BSTs which were due to the tree
        being unbalanced. Our solution to this is to balance the BST, and it will be called an AVL tree.
        Remember the two trees we drew in the assignment from lesson 33? One had a height of 5 and the
        other had a height of 3 yet there were 5 nodes in the tree. Today's lesson will look at restructuring
        the tree so that we don't have 4 "generations" on the left of the tree and 0 children on the right
        of the tree.
    </p>

    <h2>How do we rebalance the tree?</h2>
    <p>
        In a binary search tree (BST), the tree is not rebalanced automatically. In an AVL tree, the tree
        is rebalanced by performing rotations when the balance condition is violated. There are four types
        of rotations possible: LL Rotation, RR Rotation, LR Rotation, and RL Rotation. These rotations are
        performed to restore the balance of the tree and maintain the balance condition that the heights of
        the two child subtrees of any node differ by at most one. We compare the height of the left and
        right trees. If the heights are the same, this is fine. If one side has one extra generation than
        the other, then this is also fine.
    </p>

    <h2>Tell me the space and time complexity of the AVL tree.</h2>
    <p>
        The time complexity of an AVL tree is O(log n) because it is a self-balancing binary search
        tree. The balance condition is that the heights of the two child subtrees of any node differ
        by at most one. If the balance condition is violated, the tree is rebalanced to restore it.
        This means that the height of the tree is always logarithmic with respect to the number of nodes
        in the tree.
        <br>
        The space complexity of an AVL tree is O(n) because each node in the tree requires a constant
        amount of space (for storing its data and pointers to its children), and there are n nodes in
        the tree.
    </p>

    <h2>Tell me the complexity of the methods used.</h2>
    <ul>
        <li>add: The time complexity of adding a node to an AVL tree is O(log n) in both the average
            and worst cases. The space complexity of adding a node is O(1).</li>
        <li>delete: The time complexity of deleting a node from an AVL tree is O(log n) in both the
            average and worst cases. The space complexity of deleting a node is O(1).</li>
        <li>traverse: The time complexity of traversing an AVL tree is O(n) in both the average and
            worst cases. The space complexity of traversing an AVL tree is O(n) in both the average
            and worst cases.</li>
        <li>search: The time complexity of searching for a node in an AVL tree is O(log n) in both the
            average and worst cases. The space complexity of searching for a node is O(1).</li>
        <li>_right_rotate: O(1)</li>
        <li>_left_rotate: O(1)</li>
        <li>_get_min_node: O(log n)</li>
        <li>_height: O(1)</li>
        <li>_balance: O(1)</li>
    </ul>

    <h1>Code Examples</h1>
    <p>
        If you have lost the Node class, I will place it below again. You will need this to hold the
        data in the AVL tree. The only change is that we now record the height to check if the tree is
        balanced or not.
    </p>
    <div class="example">
        <div class="grid-item">
            <pre>class Node:
    def __init__(self, data):
        self.left = None
        self.right = None
        self.data = data
        self.height = 1</pre>
        </div>
        <div class="grid-item">
        </div>
    </div>

    <p>
        We have kept some of the methods and attributes from the original tree.
    </p>
    <div class="example">
        <div class="grid-item">
            <pre>class AVLTree:
    def __init__(self):
        self.root = None

    def add(self, data):
        if not self.root:
            self.root = Node(data)
        else:
            self.root = self._add(data, self.root)

    def _add(self, data, node):
        if not node:
            return Node(data)
        elif data < node.data:
            node.left = self._add(data, node.left)
        else:
            node.right = self._add(data, node.right)

        node.height = 1 + max(self._height(node.left), self._height(node.right))

        balance = self._balance(node)

        if balance > 1 and data < node.left.data:
            return self._right_rotate(node)

        if balance < -1 and data > node.right.data:
            return self._left_rotate(node)

        if balance > 1 and data > node.left.data:
            node.left = self._left_rotate(node.left)
            return self._right_rotate(node)

        if balance < -1 and data < node.right.data:
            node.right = self._right_rotate(node.right)
            return self._left_rotate(node)

        return node

    def delete(self, data):
        if not self.root:
            return None
        else:
            self.root = self._delete(data, self.root)

    def _delete(self, data, node):
        if not node:
            return None
        elif data < node.data:
            node.left = self._delete(data, node.left)
        elif data > node.data:
            node.right = self._delete(data, node.right)
        else:
            if not node.left and not node.right:
                del node
                return None
            elif not node.left:
                temp = node.right
                del node
                return temp
            elif not node.right:
                temp = node.left
                del node
                return temp
            else:
                temp = self._get_min_node(node.right)
                node.data = temp.data
                node.right = self._delete(temp.data, node.right)

        if not node:
            return None

        node.height = 1 + max(self._height(node.left), self._height(node.right))

        balance = self._balance(node)

        if balance > 1 and self._balance(node.left) >= 0:
            return self._right_rotate(node)

        if balance < -1 and self._balance(node.right) <= 0:
            return self._left_rotate(node)

        if balance > 1 and self._balance(node.left) < 0:
            node.left = self._left_rotate(node.left)
            return self._right_rotate(node)

        if balance < -1 and self._balance(node.right) > 0:
            node.right = self._right_rotate(node.right)
            return self._left_rotate(node)

        return node

    def traverse(self):
        if not self.root:
            print("Tree is empty")
        else:
            print("Inorder traversal of the AVL tree:")
            print("[", end="")
            print(*self.inorder_traverse(self.root), sep=", ", end="")
            print("]")

    def inorder_traverse(self, root):
        res = []
        if root:
            res = res + (self.inorder_traverse(root.left))
            res.append(root.data)
            res = res + (self.inorder_traverse(root.right))
        return res

    def search(self, data):
        if not self.root or not data or type(data) != int:
            print("Invalid input")
            return None
        else:
            result_node = self.search_helper(self.root, data)
            if result_node is None:
                print("Node with value " + str(data) + " is not found in the tree")
                return None
            else:
                print("Node with value " + str(data) + " is found in the tree")
                return result_node

    def search_helper(self, node, data):
        if not node:
            return None
        elif data == node.data:
            return node
        elif data < node.data:
            return self.search_helper(node.left, data)
        else:
            return self.search_helper(node.right, data)

    @staticmethod
    def _get_min_node(node):
        while node.left is not None:
            node = node.left
        return node

    @staticmethod
    def _height(node):
        if not node:
            return 0
        return node.height

    def _balance(self, node):
        if not node:
            return 0
        return self._height(node.left) - self._height(node.right)

    def _right_rotate(self, node):
        new_root = node.left
        node.left = new_root.right
        new_root.right = node

        node.height = 1 + max(self._height(node.left), self._height(node.right))
        new_root.height = 1 + max(self._height(new_root.left), self._height(new_root.right))

        return new_root

    def _left_rotate(self, node):
        new_root = node.right
        node.right = new_root.left
        new_root.left = node

        node.height = 1 + max(self._height(node.left), self._height(node.right))
        new_root.height = 1 + max(self._height(new_root.left), self._height(new_root.right))

        return new_root</pre>
        </div>
        <div class="grid-item">
        </div>
    </div>

    <h1>Exercises</h1>
    <h2>Lesson 34 Solution</h2>
    <p>
        This lesson should have hopefully answered your questions about how to make the space and time
        complexity of the BST more efficient. If you don't understand anything then read through it again
        and maybe take out some pen and paper to draw some relevant diagrams.
    </p>
    <h2>Lesson 35 Assignment</h2>
    <p>
        Take this week off before we jump to a new data structure next week. We will not be focusing
        on anything tree related next week so if you've found the last few lessons tough then hopefully
        our new topic will be a little easier. Enjoy the break!
    </p>

</main>

<footer>
    <h1>Page created by Orla</h1>
</footer>

</body>
</html>