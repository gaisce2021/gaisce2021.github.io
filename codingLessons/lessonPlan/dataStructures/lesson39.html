<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Graphs III</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>

<body>

<header>
    <p>Learn to Code</p>
</header>

<nav>
    <a href="../../../index.html">Site Home</a>
    <a href="../index.html">About Me</a>
    <div class="dropdown">
        <button class="dropbtn">Programming Basics
            <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
            <a href="../programmingBasics/lesson1.html">Lesson 1 - Getting Started</a>
            <a href="../programmingBasics/lesson2.html">Lesson 2 - Data Types</a>
            <a href="../programmingBasics/lesson3.html">Lesson 3 - Strings</a>
            <a href="../programmingBasics/lesson4.html">Lesson 4 - Booleans and Conditions</a>
            <a href="../programmingBasics/lesson5.html">Lesson 5 - Numerics and Functions</a>
            <a href="../programmingBasics/lesson6.html">Lesson 6 - Lists and Tuples</a>
            <a href="../programmingBasics/lesson7.html">Lesson 7 - Loops</a>
            <a href="../programmingBasics/lesson8.html">Lesson 8 - Print vs Return</a>
            <a href="../programmingBasics/lesson9.html">Lesson 9 - Errors</a>
            <a href="../programmingBasics/lesson10.html">Lesson 10 - Dictionaries</a>
            <a href="../programmingBasics/lesson11.html">Lesson 11 - Recursion</a>
            <a href="../programmingBasics/lesson12.html">Lesson 12 - List Comprehensions</a>
            <a href="../programmingBasics/lesson13.html">Lesson 13 - Revision</a>
        </div>
    </div>
    <div class="dropdown">
        <button class="dropbtn">Object Oriented Programming
            <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
            <a href="../oop/lesson14.html">Lesson 14 - Getting Started</a>
            <a href="../oop/lesson15.html">Lesson 15 - Inheritance</a>
            <a href="../oop/lesson16.html">Lesson 16 - Encapsulation</a>
            <a href="../oop/lesson17.html">Lesson 17 - Polymorphism</a>
            <a href="../oop/lesson18.html">Lesson 18 - Abstraction</a>
            <a href="../oop/lesson19.html">Lesson 19 - Text Based Game I</a>
            <a href="../oop/lesson20.html">Lesson 20 - Text Based Game II</a>
            <a href="../oop/lesson21.html">Lesson 21 - Text Based Game III</a>
            <a href="../oop/lesson22.html">Lesson 22 - Text Based Game IV</a>
            <a href="../oop/lesson23.html">Lesson 23 - Graphics Based Game I</a>
            <a href="../oop/lesson24.html">Lesson 24 - Graphics Based Game II</a>
            <a href="../oop/lesson25.html">Lesson 25 - Graphics Based Game III</a>
            <a href="../oop/lesson26.html">Lesson 26 - Graphics Based Game IV</a>
        </div>
    </div>
    <div class="dropdown">
        <button class="dropbtn">Data Structures
            <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
            <a href="../dataStructures/lesson27.html">Lesson 27 - Getting Started</a>
            <a href="../dataStructures/lesson28.html">Lesson 28 - Stacks</a>
            <a href="../dataStructures/lesson29.html">Lesson 29 - Queues</a>
            <a href="../dataStructures/lesson30.html">Lesson 30 - Linked Lists I</a>
            <a href="../dataStructures/lesson31.html">Lesson 31 - Linked Lists II</a>
            <a href="../dataStructures/lesson32.html">Lesson 32 - Priority Queues</a>
            <a href="../dataStructures/lesson33.html">Lesson 33 - Binary Trees</a>
            <a href="../dataStructures/lesson34.html">Lesson 34 - Binary Search Trees</a>
            <a href="../dataStructures/lesson35.html">Lesson 35 - AVL Trees</a>
            <a href="../dataStructures/lesson36.html">Lesson 36 - Deques</a>
            <a href="../dataStructures/lesson37.html">Lesson 37 - Graphs I</a>
            <a href="../dataStructures/lesson38.html">Lesson 38 - Graphs II</a>
            <a href="../dataStructures/lesson39.html">Lesson 39 - Graphs III</a>
        </div>
    </div>
    <div class="dropdown">
        <button class="dropbtn">APIs & Libraries
            <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
            <a href="../apis/lesson40.html">Lesson 40 - Getting Started</a>
            <a href="../apis/lesson41.html">Lesson 41 - Requests I</a>
            <a href="../apis/lesson42.html">Lesson 42 - Requests II</a>
            <a href="../apis/lesson43.html">Lesson 43 - Requests III</a>
            <a href="../apis/lesson44.html">Lesson 44</a>
            <a href="../apis/lesson45.html">Lesson 45</a>
            <a href="../apis/lesson46.html">Lesson 46</a>
            <a href="../apis/lesson47.html">Lesson 47</a>
            <a href="../apis/lesson48.html">Lesson 48</a>
            <a href="../apis/lesson49.html">Lesson 49</a>
            <a href="../apis/lesson50.html">Lesson 50</a>
            <a href="../apis/lesson51.html">Lesson 51</a>
            <a href="../apis/lesson52.html">Lesson 52</a>
        </div>
    </div>
</nav>

<main>
    <h1>Questions</h1>
    <h2>Are there any other data structures?</h2>
    <p>
        In this 13 week block we have looked at stacks, queues, lists, trees, deques,
        and graphs. This is only a subset of data structures. If you're interested, feel free
        to look into other trees like B trees along with maps and heaps.
    </p>

    <h2>Why did we spend weeks learning about data structures when Python has in-built ones?</h2>
    <p>
        Learning how to create your own data structure improves upon your knowledge of OOP. It
        teaches you what's going on under the hood when you use the existing Python functions.
        It gives you a greater appreciation of how to write the most efficient code when dealing
        with big data. Data structure questions are also reasonably common to be asked about in
        technical interviews when applying for jobs.
    </p>

    <h2>What other areas will I be asked about in an interviews?</h2>
    <p>
        Although each company will vary in what they ask you, you may be asked to talk the
        interviewer through a function like I was for an internship. The interviewer may ask
        you to tell them what the purpose of an unseen function is. Sorting algorithms are
        also a popular type of interview question.
    </p>

    <h2>What will we look at in the final block?</h2>
    <p>
        We will devote the last 13 weeks to APIs and working with various libraries and
        packages for specific applications.
    </p>

    <h1>Code Examples</h1>
    <p>
        As we have finished this section, there will be no code samples provided this week.
    </p>
    <h1>Exercises</h1>
    <h2>Lesson 38 Solution</h2>
    <p>
        Please see my solution below. You may be surprised by how close you got. If not, look
        through my code and yours to see where the differences lie. If your code works but looks
        slightly different, it may also be a perfectly valid solution.
    </p>
    <div class="example">
        <div class="grid-item">
            <pre>class Element:
    def __init__(self, k, v, i):
        self._key = k
        self._value = v
        self._index = i

    def __str__(self):
        return "k: %i, v: %s, i: %i" % (self._key, self._value, self._index)

    __repr__ = __str__

    def getKey(self):
        return self._key

    def setKey(self, newKey):
        self._key = newKey

    key = property(getKey, setKey)

    def getValue(self):
        return self._value

    def setValue(self, newValue):
        self._value = newValue

    value = property(getValue, setValue)

    def getIndex(self):
        return self._index

    def setIndex(self, newIndex):
        self._index = newIndex

    index = property(getIndex, setIndex)

    def __eq__(self, other):
        return self._key == other.getKey()

    def __lt__(self, other):
        return self._key < other.getKey()

    def __gt__(self, other):
        return self._key > other.getKey()


class AdaptablePriorityQueue:
    def __init__(self):
        self._binaryHeap = []

    def __str__(self):
        allTheItemsFitToPrint = ""
        for item in self._binaryHeap:
            allTheItemsFitToPrint += ("Key: %i, \t Value: %s, \t Index: %i" % (item.key, item.value, item.index)) + "\n"
        return allTheItemsFitToPrint

    __repr__ = __str__

    def length(self):
        return self._binaryHeap.__len__()

    def isEmpty(self):
        if self.length() == 0:
            return True
        return False

    def min(self):
        minItem = self._binaryHeap[0]
        return minItem.value

    def getKey(self, item):
        rightItem = self._binaryHeap[item.index]
        return rightItem.key

    def updateKey(self, item, updatedKey):
        oldKey = item.key
        item.key = updatedKey
        if oldKey < updatedKey:
            self.bubbleDown(item)
        self.bubbleUp(item)

    def add(self, key, item):
        index = self.length()
        itemIn = Element(key, item, index)
        if self.isEmpty():
            self._binaryHeap += [itemIn]
        else:
            self._binaryHeap += [itemIn]
            self.bubbleUp(itemIn)
        return itemIn


    def swap(self, item1, item2):
        index1, index2 = item1.index, item2.index
        self._binaryHeap[index1], self._binaryHeap[index2] = item2, item1
        item1.index, item2.index = index2, index1

    @staticmethod
    def parentIndex(item):
        parentIndex = (item.index - 1) // 2
        return parentIndex

    def parent(self, item):
        parentIndex = self.parentIndex(item)
        parent = self._binaryHeap[parentIndex]
        return parent

    @staticmethod
    def leftIndex(index):
        leftIndex = (2 * index) + 1
        return leftIndex

    @staticmethod
    def rightIndex(index):
        rightIndex = (2 * index) + 2
        return rightIndex

    def bubbleUp(self, itemUp):
        parentIndex = self.parentIndex(itemUp)
        if 0 <= parentIndex < self.length() - 1:
            parent = self.parent(itemUp)
            if parent.key > itemUp.key:
                self.swap(itemUp, parent)
                self.bubbleUp(itemUp)
        return self._binaryHeap

    def bubbleDown(self, itemDown):
        index = itemDown.index
        leftIndex, rightIndex = self.leftIndex(index), self.rightIndex(index)
        if rightIndex < self.length():
            leftChild, rightChild = self._binaryHeap[leftIndex], self._binaryHeap[rightIndex]
            if leftChild and rightChild:
                if leftChild.key < rightChild.key:
                    if itemDown > self._binaryHeap[leftIndex]:
                        self.swap(itemDown, leftChild)
                        self.bubbleDown(itemDown)
                elif rightChild.key < leftChild.key:
                    if itemDown.key > rightChild.key:
                        self.swap(itemDown, rightChild)
                        self.bubbleDown(itemDown)
        elif leftIndex < self.length():
            leftChild = self._binaryHeap[leftIndex]
            if itemDown.key > leftChild.key:
                self.swap(itemDown, leftChild)
                self.bubbleDown(itemDown)
        return self._binaryHeap

    def removeMin(self):
        if not self.isEmpty():
            itemOut = self._binaryHeap[0]
            if self.length() == 1:
                self._binaryHeap.pop(0)
            else:
                self.swap(self._binaryHeap[0], self._binaryHeap[-1])
                self._binaryHeap.pop(-1)
                self.bubbleDown(self._binaryHeap[0])
            return itemOut
        return None

    def remove(self, itemOut):
        if not self.isEmpty():
            currentIndex = itemOut.index
            self.swap(itemOut, self._binaryHeap[-1])
            self._binaryHeap.pop(-1)
            self.bubbleDown(self._binaryHeap[currentIndex])
            return itemOut
        return None


class Vertex:
    def __init__(self, element):
        self._element = element

    def __str__(self):
        return str(self._element)

    __repr__ = __str__

    def __lt__(self, v):
        return self._element < v.element()

    def getElement(self):
        return self._element

    def setElement(self, newElement):
        self._element = newElement

    element = property(getElement, setElement)


class Edge:
    def __init__(self, v, w, element):
        self._vertices = (v, w)
        self._element = element

    def __str__(self):
        return ('(' + str(self._vertices[0]) + '--'
                + str(self._vertices[1]) + ' : '
                + str(self._element) + ')')

    __repr__ = __str__

    def vertices(self):
        return self._vertices

    def start(self):
        return self._vertices[0]

    def end(self):
        return self._vertices[1]

    def opposite(self, v):
        if self._vertices[0] == v:
            return self._vertices[1]
        elif self._vertices[1] == v:
            return self._vertices[0]
        else:
            return None

    def getElement(self):
        return self._element

    def setElement(self, newElement):
        self._element = newElement

    element = property(getElement, setElement)


class RouteMap:
    def __init__(self):
        self._structure = dict()  # {vertex:vertex}
        self._vertexCoordinates = dict()  # {vertex:coordinates}
        self._elementVertex = dict()  # {element:vertex}

    def __graphStr(self):
        heightString = ('|V| = ' + str(self.num_vertices())
                        + '; |E| = ' + str(self.num_edges()))
        vertexString = '\nVertices: '
        for v in self._structure:
            vertexString += str(v) + '-'
        edges = self.edges()
        edgeString = '\nEdges: '
        for e in edges:
            edgeString += str(e) + ' '
        return heightString + vertexString + edgeString

    def num_vertices(self):
        return self._structure.__len__()

    def num_edges(self):
        num = 0
        for v in self._structure:
            num += len(self._structure[v])
        return num // 2

    def vertices(self):
        return [key for key in self._structure]

    def get_vertex_by_label(self, element):
        if element in self._elementVertex.keys():
            return self._elementVertex[element]
        return None

    def edges(self):
        edgeList = []
        for v in self._structure:
            for w in self._structure[v]:
                if self._structure[v][w].start() == v:
                    edgeList += [self._structure[v][w]]
        return edgeList

    def get_edges(self, v):
        if v in self._structure:
            edgeList = []
            for w in self._structure[v]:
                edgeList += [self._structure[v][w]]
            return edgeList
        return None

    def get_edge(self, v, w):
        if self._structure is not None and v in self._structure and w in self._structure[v]:
            return self._structure[v][w]
        return None

    def degree(self, v):
        return len(self._structure[v])

    def add_edge(self, v, w, element):
        if v not in self._structure or w not in self._structure:
            return None
        e = Edge(v, w, element)
        self._structure[v][w] = e
        self._structure[w][v] = e
        return e

    def add_edge_pairs(self, eList):
        for (v, w) in eList:
            self.add_edge(v, w, None)

    def highestdegreevertex(self):
        highestDegree = -1
        highestDegreeVertex = None
        for v in self._structure:
            if self.degree(v) > highestDegree:
                highestDegree = self.degree(v)
                highestDegreeVertex = v
        return highestDegreeVertex

    def __str__(self):
        if (self.num_vertices() + self.num_edges()) <= 100:
            return self.__graphStr()

    def add_vertex(self, element, coords):
        v = Vertex(element)
        self._structure[v] = dict()
        self._elementVertex[element] = v
        self._vertexCoordinates[v] = coords
        return v

    def add_vertex_if_new(self, element, coords):
        for v in self._structure:
            if v.element() == element:
                return v
        return self.add_vertex(element, coords)

    def djikstra(self, s):
        opened = AdaptablePriorityQueue()
        locsDict, closedDict, predsDict = dict(), dict(), {s: None}
        itemIn = opened.add(0, s)
        locsDict[s] = itemIn
        while not opened.isEmpty():
            costOut = opened.removeMin()
            cost, vertex = costOut.key, costOut.value
            predecessor = predsDict.pop(vertex)
            locsDict.pop(vertex)
            closedDict[vertex] = (cost, predecessor)
            for edge in self.get_edges(vertex):
                oppositeVertex = edge.opposite(vertex)
                if oppositeVertex not in closedDict:
                    newCost = cost + edge.element
                    if oppositeVertex not in locsDict:
                        predsDict[oppositeVertex] = vertex
                        item = opened.add(newCost, oppositeVertex)
                        locsDict[oppositeVertex] = item
                    elif newCost < opened.getKey(locsDict[oppositeVertex]):
                        predsDict[oppositeVertex] = vertex
                        opened.updateKey(locsDict[oppositeVertex], newCost)
        return closedDict

    def sp(self, v, w):
        djikstra = self.djikstra(v)
        vertexCurrent = None
        out = []
        djikstraValue = djikstra[w]
        cost, vertexPredecessor = djikstraValue[0], djikstraValue[1]
        out += [(w, cost)]
        while vertexCurrent is not v:
            vertexCurrent = vertexPredecessor
            djikstraValue = djikstra[vertexPredecessor]
            cost, vertexPredecessor = djikstraValue[0], djikstraValue[1]
            out += [(vertexCurrent, cost)]
        result = out[::-1]
        return result

    def printvlist(self, path):
        pathway = "type, latitude, longitude, element, cost"
        for item in path:
            vertexElement, cost = item[0], item[1]
            latitude, longitude = self._vertexCoordinates[vertexElement][0], self._vertexCoordinates[vertexElement][1]
            pathway += '\n'
            pathway += (
                    "W, %f, %f, %i, %f" %
                    (
                        latitude,
                        longitude,
                        vertexElement.element,
                        cost)
            )
        return pathway


def graphreader(filename):
    """ Read and return the route map in filename. """
    route = RouteMap()
    file = open(filename, 'r')
    entry = file.readline()  # either 'Node' or 'Edge'
    num = 0
    while entry == 'Node\n':
        num += 1
        nodeid = int(file.readline().split()[1])
        line = file.readline().split()  # line with GPS details
        coords = (float(line[1]), float(line[2]))  # latitude, longitude
        route.add_vertex(nodeid, coords)
        entry = file.readline()  # either 'Node' or 'Edge'
    print('Read', num, 'vertices and added into the graph')
    num = 0
    while entry == 'Edge\n':
        num += 1
        source = int(file.readline().split()[1])
        sv = route.get_vertex_by_label(source)
        target = int(file.readline().split()[1])
        tv = route.get_vertex_by_label(target)
        float(file.readline().split()[1])
        time = float(file.readline().split()[1])
        # oneway = (file.readline().split()[1])
        route.add_edge(sv, tv, time)
        file.readline()  # read the one-way data
        entry = file.readline()  # either 'Node' or 'Edge'
    return route</pre>
        </div>
    <div class="grid-item"></div>
    </div>
    <p>
        This assignment was given to me by a lecture in my second year of college. I received
        full marks for this assignment. The code provided here is what I submitted for grading.
        The lecturer provided us with a route map of Cork to travel between the college and a
        bar within the city. The data was provided in text files in the following format for
        us to read in and process with our graphs:
    </p>
    <pre>Node
id: 1
Node
id: 2
Node
id: 3
Node
id: 4
Node
id: 5
Node
id: 6
Node
id: 7
Node
id: 8
Node
id: 9
Node
id: 10
Node
id: 11
Node
id: 12
Node
id: 13
Node
id: 14
Node
id: 15
Node
id: 16
Node
id: 17
Node
id: 18
Node
id: 19
Node
id: 20
Node
id: 21
Node
id: 22
Node
id: 23
Node
id: 24
Node
id: 25
Node
id: 26
Node
id: 27
Node
id: 28
Edge
from: 1
to: 2
length: 2
oneway: false
Edge
from: 1
to: 4
length: 8
oneway: false
Edge
from: 2
to: 5
length: 7
oneway: false
Edge
from: 2
to: 6
length: 5
oneway: false
Edge
from: 3
to: 6
length: 4
oneway: false
Edge
from: 3
to: 10
length: 6
oneway: false
Edge
from: 3
to: 11
length: 2
oneway: false
Edge
from: 4
to: 7
length: 5
oneway: false
Edge
from: 5
to: 8
length: 3
oneway: false
Edge
from: 5
to: 9
length: 1
oneway: false
Edge
from: 6
to: 8
length: 3
oneway: false
Edge
from: 7
to: 12
length: 2
oneway: false
Edge
from: 8
to: 9
length: 5
oneway: false
Edge
from: 9
to: 15
length: 4
oneway: false
Edge
from: 10
to: 14
length: 1
oneway: false
Edge
from: 11
to: 14
length: 4
oneway: false
Edge
from: 11
to: 16
length: 3
oneway: false
Edge
from: 12
to: 15
length: 6
oneway: false
Edge
from: 13
to: 14
length: 7
oneway: false
Edge
from: 13
to: 15
length: 6
oneway: false
Edge
from: 14
to: 21
length: 5
oneway: false
Edge
from: 15
to: 17
length: 2
oneway: false
Edge
from: 15
to: 18
length: 5
oneway: false
Edge
from: 15
to: 20
length: 3
oneway: false
Edge
from: 16
to: 19
length: 4
oneway: false
Edge
from: 17
to: 22
length: 6
oneway: false
Edge
from: 18
to: 20
length: 4
oneway: false
Edge
from: 18
to: 21
length: 8
oneway: false
Edge
from: 19
to: 23
length: 6
oneway: false
Edge
from: 20
to: 24
length: 1
oneway: false
Edge
from: 21
to: 25
length: 8
oneway: false
Edge
from: 22
to: 24
length: 5
oneway: false
Edge
from: 22
to: 26
length: 7
oneway: false
Edge
from: 23
to: 28
length: 5
oneway: false
Edge
from: 24
to: 26
length: 6
oneway: false
Edge
from: 24
to: 27
length: 10
oneway: false
Edge
from: 25
to: 27
length: 5
oneway: false
Edge
from: 25
to: 28
length: 4
oneway: false
Edge
from: 26
to: 27
length: 3
oneway: false
Edge
from: 27
to: 28
length: 3
oneway: false</pre>
    <h2>Lesson 39 Assignment</h2>
    <p>
        As per our usual arrangement, there is no assignment at the end of this block of
        lessons. Feel free to enjoy a break between lessons or move straight forward to the
        following block of lessons for a new challenge.
    </p>
</main>

<footer>
    <h1>Page created by Orla</h1>
</footer>

</body>
</html>