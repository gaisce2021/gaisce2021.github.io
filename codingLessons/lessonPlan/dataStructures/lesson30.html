<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Linked Lists I</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>

<body>

<header>
    <p>Learn to Code</p>
</header>

<nav>
    <a href="../../../index.html">Site Home</a>
    <a href="../index.html">About Me</a>
    <div class="dropdown">
        <button class="dropbtn">Programming Basics
            <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
            <a href="../programmingBasics/lesson1.html">Lesson 1 - Getting Started</a>
            <a href="../programmingBasics/lesson2.html">Lesson 2 - Data Types</a>
            <a href="../programmingBasics/lesson3.html">Lesson 3 - Strings</a>
            <a href="../programmingBasics/lesson4.html">Lesson 4 - Booleans and Conditions</a>
            <a href="../programmingBasics/lesson5.html">Lesson 5 - Numerics and Functions</a>
            <a href="../programmingBasics/lesson6.html">Lesson 6 - Lists and Tuples</a>
            <a href="../programmingBasics/lesson7.html">Lesson 7 - Loops</a>
            <a href="../programmingBasics/lesson8.html">Lesson 8 - Print vs Return</a>
            <a href="../programmingBasics/lesson9.html">Lesson 9 - Errors</a>
            <a href="../programmingBasics/lesson10.html">Lesson 10 - Dictionaries</a>
            <a href="../programmingBasics/lesson11.html">Lesson 11 - Recursion</a>
            <a href="../programmingBasics/lesson12.html">Lesson 12 - List Comprehensions</a>
            <a href="../programmingBasics/lesson13.html">Lesson 13 - Revision</a>
        </div>
    </div>
    <div class="dropdown">
        <button class="dropbtn">Object Oriented Programming
            <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
            <a href="../oop/lesson14.html">Lesson 14 - Getting Started</a>
            <a href="../oop/lesson15.html">Lesson 15 - Inheritance</a>
            <a href="../oop/lesson16.html">Lesson 16 - Encapsulation</a>
            <a href="../oop/lesson17.html">Lesson 17 - Polymorphism</a>
            <a href="../oop/lesson18.html">Lesson 18 - Abstraction</a>
            <a href="../oop/lesson19.html">Lesson 19 - Text Based Game I</a>
            <a href="../oop/lesson20.html">Lesson 20 - Text Based Game II</a>
            <a href="../oop/lesson21.html">Lesson 21 - Text Based Game III</a>
            <a href="../oop/lesson22.html">Lesson 22 - Text Based Game IV</a>
            <a href="../oop/lesson23.html">Lesson 23 - Graphics Based Game I</a>
            <a href="../oop/lesson24.html">Lesson 24 - Graphics Based Game II</a>
            <a href="../oop/lesson25.html">Lesson 25 - Graphics Based Game III</a>
            <a href="../oop/lesson26.html">Lesson 26 - Graphics Based Game IV</a>
        </div>
    </div>
    <div class="dropdown">
        <button class="dropbtn">Data Structures
            <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
            <a href="../dataStructures/lesson27.html">Lesson 27 - Getting Started</a>
            <a href="../dataStructures/lesson28.html">Lesson 28 - Stacks</a>
            <a href="../dataStructures/lesson29.html">Lesson 29 - Queues</a>
            <a href="../dataStructures/lesson30.html">Lesson 30 - Linked Lists I</a>
            <a href="../dataStructures/lesson31.html">Lesson 31 - Linked Lists II</a>
            <a href="../dataStructures/lesson32.html">Lesson 32 - Priority Queues</a>
            <a href="../dataStructures/lesson33.html">Lesson 33 - Binary Trees</a>
            <a href="../dataStructures/lesson34.html">Lesson 34 - Binary Search Trees</a>
            <a href="../dataStructures/lesson35.html">Lesson 35 - AVL Trees</a>
            <a href="../dataStructures/lesson36.html">Lesson 36 - Deques</a>
            <a href="../dataStructures/lesson37.html">Lesson 37 - Graphs I</a>
            <a href="../dataStructures/lesson38.html">Lesson 38 - Graphs II</a>
            <a href="../dataStructures/lesson39.html">Lesson 39 - Graphs III</a>
        </div>
    </div>
    <div class="dropdown">
        <button class="dropbtn">APIs & Libraries
            <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
            <a href="../apis/lesson40.html">Lesson 40 - Getting Started</a>
            <a href="../apis/lesson41.html">Lesson 41 - Requests I</a>
            <a href="../apis/lesson42.html">Lesson 42 - Requests II</a>
            <a href="../apis/lesson43.html">Lesson 43 - Requests III</a>
            <a href="../apis/lesson44.html">Lesson 44</a>
            <a href="../apis/lesson45.html">Lesson 45</a>
            <a href="../apis/lesson46.html">Lesson 46</a>
            <a href="../apis/lesson47.html">Lesson 47</a>
            <a href="../apis/lesson48.html">Lesson 48</a>
            <a href="../apis/lesson49.html">Lesson 49</a>
            <a href="../apis/lesson50.html">Lesson 50</a>
            <a href="../apis/lesson51.html">Lesson 51</a>
            <a href="../apis/lesson52.html">Lesson 52</a>
        </div>
    </div>
</nav>

<main>
    <h1>Questions</h1>
    <h2>What will we cover after the stack and the queue?</h2>
    <p>
        This week and next week will focus on linked lists. We will look at the singly linked list (SLL) this
        week and the doubly linked list (DLL) next week. You can think of these as alternatives to the
        standard Python array in built to the programming language.
    </p>
    <h2>What does the SLL need?</h2>
    <p>
        A singly linked list needs a Node class that stores the data and a reference to the next node. Once
        you have built the node class, you need a List class. This class needs a head pointer which denotes
        where the list starts. Each node has a next pointer which tells the code where the next item in the
        list is stored. We will need some methods to insert, delete, search, and traverse the list.
    </p>
    <h2>Tell me the space/time complexity of the methods in the SLL.</h2>
    <p>
        The time complexity of the <i>insert</i> method is O(n) in the worst case because it needs to
        traverse the entire list to find the last node. The space complexity of this method is O(1)
        because it only creates a new node.
        <br>
        The time complexity of the <i>delete</i> method is O(n) in the worst case because it needs
        to traverse the entire list to find the node to delete. The space complexity of this method
        is O(1) because it only deletes a node.
        <br>
        The time complexity of the <i>search</i> method is O(n) in the worst case because it needs
        to traverse the entire list to find the node. The space complexity of this method is O(1)
        because it only searches for a node.
        <br>
        The time complexity of the <i>traverse</i> method is O(n) because it needs to traverse
        the entire list. The space complexity of this method is O(1) because it only prints out
        data from each node.
    </p>

    <h2>Why build the SLL when you can use a Python array?</h2>
    <p>
        There are several reasons why you might choose to use the SLL over an array in Python. One reason
        is that linked lists can be more efficient than arrays when it comes to inserting or
        deleting elements in the middle of the list. This is because linked lists don't require
        shifting elements around like arrays do. Another reason is that linked lists can be more
        memory-efficient than arrays when you don't know how many elements you'll need ahead of
        time. This is because linked lists can grow dynamically as you add elements, whereas arrays
        have a fixed size. Python arrays require a fixed block of memory, SLLs can store elements in smaller
        free spaces due to their use of pointers. Put it this way: is it easier to stuff an entire PS4 into
        a drawer or a collection of smaller objects like socks or cutlery?
    </p>

    <h2>Does the SLL have any downsides?</h2>
    <p>
        However, there are also some downsides to using linked lists. For example, accessing an element
        in a linked list takes O(n) time in the worst case, whereas accessing an element in an array
        takes O(1) time. Additionally, linked lists use more memory than arrays because each node
        has a pointer to the next node. This may sound like a contradiction of the above but the array,
        because it takes a fixed block of memory, can store each element side by side. The SLL on the other
        hand has the additional problem of needing pointers as, in the example above, you may store your
        socks in two separate drawers but the PS4 is an inseparable block.
    </p>

    <h1>Code Examples</h1>
    <p>
        We will first create a Node class to hold each piece of data in our list.
    </p>
    <div class="example">
        <div class="grid-item">
            <pre>class Node:
    def __init__(self, data):
        self.data = data
        self.next = None</pre>
        </div>
        <div class="grid-item">

        </div>
    </div>

    <p>
        Now let's look at a complete SLL class which takes in a Node item. We will have a head pointer and,
        as we have seen from the above code, each Node item has a <i>next</i> pointer. The <i>insert</i>
        function will convert any new data into a node and place it at the end. The <i>delete</i> function
        will delete the first instance of the node in the list if it is there. It will then "bridge" the
        missing link in the list by amending the pointer of the data before the deleted node to point at the
        data after the deleted node. <i>Search</i> returns True if a node is in the list and False if not.
        <i>Traverse</i> goes through the list and shows you each item one by one.
    </p>
    <div class="example">
        <div class="grid-item">
            <pre>class SLL:
    def __init__(self):
        self.head = None

    def insert(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            return
        last_node = self.head
        while last_node.next:
            last_node = last_node.next
        last_node.next = new_node

    def delete(self, key):
        cur_node = self.head
        if cur_node and cur_node.data == key:
            self.head = cur_node.next
            cur_node = None
            return
        prev = None
        while cur_node and cur_node.data != key:
            prev = cur_node
            cur_node = cur_node.next
        if cur_node is None:
            return
        prev.next = cur_node.next
        cur_node = None

    def search(self, key):
        cur_node = self.head
        while cur_node:
            if cur_node.data == key:
                return True
            cur_node = cur_node.next
        return False

    def traverse(self):
        if self.head is None:
            print("List is empty")
            return

        cur_node = self.head
        while cur_node:
            print(cur_node.data, end="")
            if cur_node.next:
                print(" -> ", end="")
            cur_node = cur_node.next</pre>
        </div>
        <div class="grid-item">

        </div>
    </div>

    <h1>Exercises</h1>
    <h2>Lesson 29 Solution</h2>
    <p>
        As a fun exercise, you can consider amending the queue to print out the customers yet to be served.
        See a solution to last week's exercise below.
    </p>
    <div class="example">
        <div class="grid-item">
            <pre>mary = Customer("Mary", "strawberry ice cream")
john = Customer("John", "mint ice cream")
anne = Customer("Anne", "vanilla ice cream")
tommy = Customer("Tommy", "cookie dough ice cream")
joe_biden = Customer("Joe Biden", "chocolate chip ice cream")
secret_service_agent_1 = Customer("Secret Service Agent 1", "REDACTED ice cream")
secret_service_agent_2 = Customer("Secret Service Agent 2", "REDACTED ice cream")
secret_service_agent_3 = Customer("Secret Service Agent 3", "REDACTED ice cream")
secret_service_agent_4 = Customer("Secret Service Agent 4", "REDACTED ice cream")

queue = Queue()

queue.enqueue(mary)
queue.enqueue(john)

print(queue.peek().get_order())

queue.dequeue()
queue.dequeue()

queue.enqueue(anne)
queue.enqueue(tommy)

queue.dequeue()

queue.enqueue(joe_biden)
queue.enqueue(secret_service_agent_1)

queue.dequeue()
queue.dequeue()
print(queue.size())

queue.enqueue(secret_service_agent_2)
queue.enqueue(secret_service_agent_3)
queue.enqueue(secret_service_agent_4)

while not queue.isEmpty():
    queue.dequeue().get_order()</pre>
        </div>
        <div class="grid-item">
            <br><br><br><br><br><br><br><br>
            <br><br><br><br><br><br><br><br>
            Mary ordered strawberry ice cream<br>
            <br><br><br><br><br><br><br><br>
            <br><br><br><br><br><br>
            1
        </div>
    </div>

    <h2>Lesson 30 Assignment</h2>
    <p>
        This assignment will involve creating and using all the functions of the SLL. It shouldn't be too
        difficult. We will create a small list and use the add/delete/search/traverse functions. This list
        will be based on the US presidents. We will purposely add one of them in at the wrong point and
        remove them. Please note that we can only remove the first instance of an item in the list. You may
        want to update the code to specify "please remove the 7th occurrence of node X" but this will not
        be a requirement.
    </p>
    <ol>
        <li>Add George Washington, John Adams and James Madison.</li>
        <li>Traverse the list.</li>
        <li>Delete James Madison and add Thomas Jefferson (we purposely made a mistake here).</li>
        <li>Add "..." to the list (unless you're comfortable adding over 40 more names in the middle).</li>
        <li>Add Bill Clinton, Hillary Clinton and George W Bush.</li>
        <li>Remove Hillary Clinton as she was not elected.</li>
        <li>Search for Barack Obama. If False then use the insert function, so he will be at
            the end of the list</li>
        <li>Insert Donald Trump and Joe Biden.</li>
        <li>Use the traverse function and confirm your list is correctly ordered.</li>
    </ol>
    <p>
        This shouldn't be the most difficult assignment but check in next week to confirm you
        have the right answer. Good luck!
    </p>
</main>

<footer>
    <h1>Page created by Orla</h1>
</footer>

</body>
</html>